diff --git a/ldebug.c b/ldebug.c
index a716d95e..f375da99 100644
--- a/ldebug.c
+++ b/ldebug.c
@@ -133,6 +133,10 @@ LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
     mask = 0;
     func = NULL;
   }
+#ifndef MAGMA_ENABLE_FIXES
+  if (isLua(L->ci))
+      L->oldpc = L->ci->u.l.savedpc; // LUA004.patch
+#endif
   L->hook = func;
   L->basehookcount = count;
   resethookcount(L);
@@ -184,8 +188,16 @@ static const char *upvalname (const Proto *p, int uv) {
 static const char *findvararg (CallInfo *ci, int n, StkId *pos) {
   if (clLvalue(s2v(ci->func))->p->is_vararg) {
     int nextra = ci->u.l.nextraargs;
+#ifdef MAGMA_ENABLE_FIXES
     if (n >= -nextra) {  /* 'n' is negative */
       *pos = ci->func - nextra - (n + 1);
+#else
+    if (n <= nextra) {
+#ifdef MAGMA_ENABLE_CANARIES
+      MAGMA_LOG("%MAGMA_BUG%", INT_MAX - nextra <= (n - 1));
+#endif
+      *pos = ci->func - nextra + (n - 1); // LUA001.patch
+#endif
       return "(vararg)";  /* generic name for any vararg */
     }
   }
@@ -198,7 +210,11 @@ const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {
   const char *name = NULL;
   if (isLua(ci)) {
     if (n < 0)  /* access to vararg values? */
+#ifdef MAGMA_ENABLE_FIXES
       return findvararg(ci, n, pos);
+#else
+      return findvararg(ci, -n, pos); // LUA001.patch
+#endif
     else
       name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));
   }
@@ -839,8 +855,15 @@ l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {
 ** so it goes directly to 'luaG_getfuncline'.
 */
 static int changedline (const Proto *p, int oldpc, int newpc) {
+#ifdef MAGMA_ENABLE_FIXES
   if (p->lineinfo == NULL)  /* no debug information? */
     return 0;
+#else
+#ifdef MAGMA_ENABLE_CANARIES
+  MAGMA_LOG("%MAGMA_BUG%", p->lineinfo == NULL);
+#endif
+#endif
+  // LUA002.patch
   if (newpc - oldpc < MAXIWTHABS / 2) {  /* not too far apart? */
     int delta = 0;  /* line diference */
     int pc = oldpc;
@@ -874,7 +897,9 @@ static int changedline (const Proto *p, int oldpc, int newpc) {
 int luaG_traceexec (lua_State *L, const Instruction *pc) {
   CallInfo *ci = L->ci;
   lu_byte mask = L->hookmask;
-  const Proto *p = ci_func(ci)->p;
+#ifdef MAGMA_ENABLE_FIXES
+  const Proto *p = ci_func(ci)->p; // LUA004.patch
+#endif
   int counthook;
   if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */
     ci->u.l.trap = 0;  /* don't need to stop again */
@@ -896,15 +921,32 @@ int luaG_traceexec (lua_State *L, const Instruction *pc) {
   if (counthook)
     luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */
   if (mask & LUA_MASKLINE) {
+#ifdef MAGMA_ENABLE_FIXES
     /* 'L->oldpc' may be invalid; use zero in this case */
     int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;
+#else
+    const Proto *p = ci_func(ci)->p; // LUA004.patch
+#endif
     int npci = pcRel(pc, p);
+#ifdef MAGMA_ENABLE_FIXES
     if (npci <= oldpc ||  /* call hook when jump back (loop), */
         changedline(p, oldpc, npci)) {  /* or when enter new line */
-      int newline = luaG_getfuncline(p, npci);
+#else
+#ifdef MAGMA_ENABLE_CANARIES
+    MAGMA_LOG("%MAGMA_BUG%", pcRel(L->oldpc, p) < 0);
+#endif
+    if (npci == 0 ||
+        pc <= L->oldpc ||
+        changedline(p, pcRel(L->oldpc, p), npci)) {
+#endif
+      int newline = luaG_getfuncline(p, npci);// LUA004.patch
       luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */
     }
+#ifdef MAGMA_ENABLE_FIXES
     L->oldpc = npci;  /* 'pc' of last call to line hook */
+#else
+    L->oldpc = pc;// LUA004.patch
+#endif
   }
   if (L->status == LUA_YIELD) {  /* did hook yield? */
     if (counthook)
@@ -915,4 +957,3 @@ int luaG_traceexec (lua_State *L, const Instruction *pc) {
   }
   return 1;  /* keep 'trap' on */
 }
-
diff --git a/ldo.c b/ldo.c
index a48e35f9..f0360cb4 100644
--- a/ldo.c
+++ b/ldo.c
@@ -368,7 +368,11 @@ static void rethook (lua_State *L, CallInfo *ci, int nres) {
     int delta = 0;  /* correction for vararg functions */
     int ftransfer;
     if (isLua(ci)) {
+#ifdef MAGMA_ENABLE_FIXES
       Proto *p = ci_func(ci)->p;
+#else
+      Proto *p = clLvalue(s2v(ci->func))->p;// LUA004.patch
+#endif
       if (p->is_vararg)
         delta = ci->u.l.nextraargs + p->numparams + 1;
     }
@@ -377,8 +381,13 @@ static void rethook (lua_State *L, CallInfo *ci, int nres) {
     luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  /* call it */
     ci->func -= delta;
   }
+#ifdef MAGMA_ENABLE_FIXES
   if (isLua(ci = ci->previous))
     L->oldpc = pcRel(ci->u.l.savedpc, ci_func(ci)->p);  /* set 'oldpc' */
+#else
+  if (isLua(ci->previous))
+    L->oldpc = ci->previous->u.l.savedpc;// LUA004.patch
+#endif
 }
 
 
@@ -993,5 +1002,3 @@ int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
   decnny(L);
   return status;
 }
-
-
diff --git a/liolib.c b/liolib.c
index b08397da..ec1bb1b3 100644
--- a/liolib.c
+++ b/liolib.c
@@ -291,7 +291,14 @@ static int io_popen (lua_State *L) {
   const char *filename = luaL_checkstring(L, 1);
   const char *mode = luaL_optstring(L, 2, "r");
   LStream *p = newprefile(L);
+#ifdef MAGMA_ENABLE_FIXES
   luaL_argcheck(L, l_checkmodep(mode), 2, "invalid mode");
+#else
+#ifdef MAGMA_ENABLE_CANARIES
+  MAGMA_LOG("%MAGMA_BUG%", !l_checkmodep(mode));
+#endif
+#endif
+  // LUA003.patch
   p->f = l_popen(L, filename, mode);
   p->closef = &io_pclose;
   return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
@@ -825,4 +832,3 @@ LUAMOD_API int luaopen_io (lua_State *L) {
   createstdfile(L, stderr, NULL, "stderr");
   return 1;
 }
-
diff --git a/lstate.c b/lstate.c
index 1ffe1a0f..2e90fddc 100644
--- a/lstate.c
+++ b/lstate.c
@@ -262,7 +262,9 @@ static void preinit_thread (lua_State *L, global_State *g) {
   L->openupval = NULL;
   L->status = LUA_OK;
   L->errfunc = 0;
-  L->oldpc = 0;
+#ifdef ENABLE_MAGMA_FIXES
+  L->oldpc = 0;// LUA004.patch
+#endif
 }
 
 
@@ -437,4 +439,3 @@ void luaE_warnerror (lua_State *L, const char *where) {
   luaE_warning(L, msg, 1);
   luaE_warning(L, ")", 0);
 }
-
diff --git a/lstate.h b/lstate.h
index 61e82cde..044a6688 100644
--- a/lstate.h
+++ b/lstate.h
@@ -309,6 +309,9 @@ struct lua_State {
   StkId top;  /* first free slot in the stack */
   global_State *l_G;
   CallInfo *ci;  /* call info for current function */
+#ifndef MAGMA_ENABLE_FIXES
+  const Instruction *oldpc;// LUA004.patch
+#endif
   StkId stack_last;  /* end of stack (last element + 1) */
   StkId stack;  /* stack base */
   UpVal *openupval;  /* list of open upvalues in this stack */
@@ -320,7 +323,9 @@ struct lua_State {
   volatile lua_Hook hook;
   ptrdiff_t errfunc;  /* current error handling function (stack index) */
   l_uint32 nCcalls;  /* number of nested (non-yieldable | C)  calls */
-  int oldpc;  /* last pc traced */
+#ifdef MAGMA_ENABLE_FIXES
+  int oldpc;  /* last pc traced */// LUA004.patch
+#endif
   int basehookcount;
   int hookcount;
   volatile l_signalT hookmask;
@@ -401,4 +406,3 @@ LUAI_FUNC int luaE_resetthread (lua_State *L, int status);
 
 
 #endif
-
diff --git a/lvm.c b/lvm.c
index 2ec34400..fdd5139e 100644
--- a/lvm.c
+++ b/lvm.c
@@ -1824,7 +1824,11 @@ void luaV_execute (lua_State *L, CallInfo *ci) {
         ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
         if (l_unlikely(trap)) {  /* previous "Protect" updated trap */
           luaD_hookcall(L, ci);
+#ifdef MAGMA_ENABLE_FIXES
           L->oldpc = 1;  /* next opcode will be seen as a "new" line */
+#else
+          L->oldpc = pc + 1;// LUA004.patch
+#endif
         }
         updatebase(ci);  /* function has new base after adjustment */
         vmbreak;
